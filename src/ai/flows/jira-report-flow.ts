
'use server';
/**
 * @fileOverview An AI agent that analyzes Jira issues from an Excel export and generates a summary report.
 *
 * - generateJiraReport - A function that takes Jira issue data and returns a structured report.
 * - JiraReportInput - The input type for the generateJiraReport function.
 * - JiraReportOutput - The return type for the generateJiraReport function.
 */

import { ai } from '@/ai/genkit';
import { z } from 'zod';

const JiraReportInputSchema = z.object({
  issuesData: z.string().describe("A stringified JSON array of arrays representing the Jira issues from an Excel sheet. The first inner array is the header row."),
  analysisPoint: z.string().optional().describe("An optional user-provided focus point for the analysis, e.g., 'Reporter', 'Priority', or specific keywords."),
});
export type JiraReportInput = z.infer<typeof JiraReportInputSchema>;

// Schema for the final, cleaned breakdown item. All essential fields are required.
const FinalIssueBreakdownItemSchema = z.object({
    issueKey: z.string(),
    summary: z.string(),
    status: z.string(),
    assignee: z.string(),
    recommendation: z.string(),
    createdDate: z.string().optional(),
    resolvedDate: z.string().optional(),
});

// Schema for the raw AI output, allowing some fields to be optional to prevent validation errors.
const RawIssueBreakdownItemSchema = FinalIssueBreakdownItemSchema.deepPartial().extend({
    issueKey: z.string().optional(), // issueKey is critical but we handle its absence in the filter.
    summary: z.string().optional(),
});

const StatusDistributionItemSchema = z.object({
    name: z.string().describe("The issue status (e.g., 'Closed', 'In Progress')."),
    value: z.number().describe("The total count of issues for that status."),
    fill: z.string().describe("A hex color code for the chart slice, generated by you."),
});

const JiraReportOutputSchema = z.object({
  summary: z.string().describe("A high-level summary of all the issues provided. It should mention the total number of issues, how many are open, in progress, and done. Mention any noticeable trends or bottlenecks."),
  priorityActions: z.array(z.string()).describe("A bulleted list of the most critical actions to take, based on issue priority, status, and content. Max 3-5 items."),
  issueBreakdown: z.array(FinalIssueBreakdownItemSchema).describe("A detailed breakdown of each individual issue."),
  statusDistribution: z.array(StatusDistributionItemSchema).describe("Data for a pie chart showing the distribution of issues by status. The 'fill' color should be a visually distinct hex color for each status."),
});
export type JiraReportOutput = z.infer<typeof JiraReportOutputSchema>;

const IssueBreakdownOnlySchema = z.object({
    issueBreakdown: z.array(RawIssueBreakdownItemSchema),
});

const SummarizeInputSchema = z.object({
    breakdownString: z.string(),
    analysisPoint: z.string().optional(),
    currentDate: z.string(),
});

const SummaryAndActionsSchema = z.object({
    summary: z.string().describe("A high-level summary of all the issues provided. It should mention the total number of issues, how many are open, in progress, and done. Mention any noticeable trends or bottlenecks."),
    priorityActions: z.array(z.string()).describe("A bulleted list of the most critical actions to take, based on issue priority, status, and content. Max 3-5 items."),
    statusDistribution: z.array(StatusDistributionItemSchema).describe("Data for a pie chart showing the distribution of issues by status. The 'fill' color should be a visually distinct hex color for each status."),
});

const createBreakdownPrompt = ai.definePrompt({
  name: "createBreakdownPrompt",
  input: { schema: z.object({ issuesData: z.string() }) },
  output: { schema: IssueBreakdownOnlySchema }, // Use the lenient schema for raw output
  prompt: `You are a machine that converts raw Jira data into a JSON object.
Your ONLY output should be a valid JSON object with a single "issueBreakdown" key.

**CRITICAL RULES to prevent errors:**
1.  **PROCESS ONLY VALID ROWS**: A row is valid ONLY IF it contains BOTH an 'Issue Key' (like 'ABC-123') AND a 'Summary' value.
2.  **IGNORE ALL OTHER ROWS**: You MUST completely ignore any row that is empty, incomplete, or does not have both an Issue Key and a Summary. If a row only has an assignee, or only a status, IGNORE IT. DO NOT create a JSON object for such rows.
3.  For EACH valid row, create a complete JSON object with all fields from the schema.
4.  **DATE EXTRACTION**: Look for date columns like 'Created', 'Resolved', '생성일', '해결일'. If found, add their values to 'createdDate' and 'resolvedDate' fields. If not found, omit these fields.
5.  **SHORTEN CONTENT**:
    -   'summary': MUST be a VERY SHORT summary of the original issue title, **under 15 words**.
    -   'recommendation': MUST be a VERY SHORT, actionable recommendation in **KOREAN**, **under 10 words**.
6.  **VALID JSON**: Your entire response MUST be a single, valid, complete, and parseable JSON object.

**Jira Data:**
{{{issuesData}}}

Now, generate the JSON object based on the provided Jira Data, strictly following all rules.`,
});

const summarizeBreakdownPrompt = ai.definePrompt({
  name: "summarizeBreakdownPrompt",
  input: { schema: SummarizeInputSchema },
  output: { schema: SummaryAndActionsSchema },
  prompt: `You are a project management expert who writes reports in KOREAN.
Based on the following JSON data of Jira issues, generate a high-level summary, a list of priority actions, and data for a status chart.
Today's date is {{{currentDate}}}.

{{#if analysisPoint}}
The user wants you to specifically focus on '{{{analysisPoint}}}'. Pay close attention to this when creating the summary and priority actions.

**CRITICAL INSTRUCTIONS FOR DATE-BASED ANALYSIS:**
1.  The 'createdDate' and 'resolvedDate' fields are in 'YYYY-MM-DD' or 'YYYY-MM-DD HH:mm' format.
2.  When the user asks for a specific month (e.g., '2월에 해결된 이슈' which means 'issues resolved in February'), you MUST filter the 'issueBreakdown' data to include ONLY the issues that match that month. For '2월' (February), the month part of the date must be '02'.
3.  Your entire summary and priority actions MUST be based ONLY on the filtered data. Do NOT include issues from other months in your analysis.
4.  For other queries (e.g., a specific person, a keyword), filter by 'assignee' or search the 'summary' to focus your report.

{{else}}
Provide a general analysis. Mention any noticeable trends, risks, or bottlenecks.
{{/if}}

**Issue Breakdown Data (JSON):**
{{{breakdownString}}}

**Instructions:**
Your entire response MUST be a single, valid JSON object with THREE keys: "statusDistribution", "summary", and "priorityActions".

1.  **\`statusDistribution\` (array of objects, English keys):**
    -   First, analyze the \`status\` field for every issue in the provided JSON data.
    -   Count the number of issues for each unique status (e.g., 'Closed', 'Build request').
    -   Create a JSON array where each object represents a status.
    -   Each object MUST have three keys: \`name\` (string, the status), \`value\` (number, the count), and \`fill\` (string, a unique, visually distinct hex color code like "#8884d8" that you generate).
    -   Example: \`[{"name": "Closed", "value": 25, "fill": "#82ca9d"}, {"name": "In Progress", "value": 10, "fill": "#ffc658"}]\`

2.  **\`summary\` (string, in Korean):**
    -   Write a high-level summary of the ANALYZED (and potentially filtered) issues.
    -   **Use the status counts from your \`statusDistribution\` analysis** to mention the total issues and the breakdown by status.
    -   {{#if analysisPoint}}Incorporate the user's analysis point '{{{analysisPoint}}}' into your summary.{{else}}Mention any noticeable trends, risks, or bottlenecks.{{/if}}

3.  **\`priorityActions\` (array of strings, in Korean):**
    -   List the top 3-5 most critical, actionable items for the team to focus on, based on the ANALYZED (and potentially filtered) issues.
    -   {{#if analysisPoint}}These actions should be heavily influenced by the analysis point '{{{analysisPoint}}}'.{{/if}}

Now, generate the JSON object based on the provided Issue Breakdown Data, strictly following all analysis rules. The text for summary and priorityActions must be in KOREAN.`,
});


export async function generateJiraReport(input: JiraReportInput): Promise<JiraReportOutput> {
  // Step 1: Generate the issue breakdown with a lenient schema.
  const { output: breakdownOutput } = await createBreakdownPrompt({ issuesData: input.issuesData });
  if (!breakdownOutput || !Array.isArray(breakdownOutput.issueBreakdown)) {
      throw new Error('AI가 이슈 세부 항목을 생성하는 데 실패했습니다.');
  }

  // Step 2: Server-side filtering to guarantee data integrity.
  // This is the critical step to prevent errors from incomplete AI output.
  const filteredBreakdown = breakdownOutput.issueBreakdown.filter(
      (issue): issue is z.infer<typeof FinalIssueBreakdownItemSchema> =>
          !!issue &&
          typeof issue.issueKey === 'string' && issue.issueKey.trim() !== '' &&
          typeof issue.summary === 'string' && issue.summary.trim() !== '' &&
          typeof issue.status === 'string' &&
          typeof issue.assignee === 'string' &&
          typeof issue.recommendation === 'string'
  );
  
  if (filteredBreakdown.length === 0) {
       throw new Error('AI가 유효한 이슈를 분석하지 못했습니다. 데이터에 이슈 키와 요약 정보가 포함되어 있는지 확인해주세요.');
  }

  // Step 3: Generate the summary and actions from the filtered breakdown
  const { output: summaryOutput } = await summarizeBreakdownPrompt({
      breakdownString: JSON.stringify(filteredBreakdown),
      analysisPoint: input.analysisPoint,
      currentDate: new Date().toLocaleDateString('ko-KR'),
  });
  if (!summaryOutput) {
      throw new Error('AI가 요약 및 조치 항목을 생성하는 데 실패했습니다.');
  }

  // Step 4: Combine the results
  return {
      summary: summaryOutput.summary,
      priorityActions: summaryOutput.priorityActions,
      issueBreakdown: filteredBreakdown,
      statusDistribution: summaryOutput.statusDistribution,
  };
}
