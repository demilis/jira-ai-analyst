
'use server';
/**
 * @fileOverview Jira 데이터를 분석하여 종합 리포트를 생성하는 AI 에이전트입니다.
 * 이 파일은 앱의 '뇌' 역할을 하며, `jira-service`를 통해 가져온 원본 데이터를
 * 지능적으로 분석하고, 요약하며, 실행 가능한 인사이트를 생성합니다.
 *
 * - generateJiraReport - 클라이언트에서 호출하는 메인 함수입니다.
 * - JiraReportInput - AI 분석을 위한 입력 데이터의 타입 정의입니다.
 * - JiraReportOutput - AI가 최종적으로 생성하는 리포트의 타입 정의입니다.
 */

import { ai } from '@/ai/genkit';
import { z } from 'zod';

const JiraReportInputSchema = z.object({
  issuesData: z.string().describe("A stringified JSON array of arrays representing the Jira issues from an Excel sheet. The first inner array is the header row."),
  analysisPoint: z.string().optional().describe("An optional user-provided focus point for the analysis, e.g., 'Reporter', 'Priority', or specific keywords."),
  currentDate: z.string().describe("The current date for reference in date-based queries like 'last week'."),
});
export type JiraReportInput = z.infer<typeof JiraReportInputSchema>;

// Schema for the items in the final report.
const IssueBreakdownItemSchema = z.object({
    issueKey: z.string(),
    summary: z.string(),
    status: z.string(),
    assignee: z.string(),
    recommendation: z.string(),
    createdDate: z.string().optional(),
    resolvedDate: z.string().optional(),
});

const StatusDistributionItemSchema = z.object({
    name: z.string().describe("The issue status (e.g., 'Closed', 'In Progress')."),
    value: z.number().describe("The total count of issues for that status."),
    fill: z.string().describe("A hex color code for the chart slice, generated by you."),
});

const JiraReportOutputSchema = z.object({
  summary: z.string().describe("A high-level summary of all the issues provided. It should mention the total number of issues, how many are open, in progress, and done. Mention any noticeable trends or bottlenecks."),
  priorityActions: z.array(z.string()).describe("A bulleted list of the most critical actions to take, based on issue priority, status, and content. Max 3-5 items."),
  issueBreakdown: z.array(IssueBreakdownItemSchema).describe("A detailed breakdown of each individual issue."),
  statusDistribution: z.array(StatusDistributionItemSchema).describe("Data for a pie chart showing the distribution of issues by status. The 'fill' color should be a visually distinct hex color for each status."),
});
export type JiraReportOutput = z.infer<typeof JiraReportOutputSchema>;


/**
 * The main exported function that the client-side calls.
 * It prepares the input and invokes the Genkit flow.
 */
export async function generateJiraReport(input: { issuesData: string; analysisPoint?: string }): Promise<JiraReportOutput> {
    const fullInput: JiraReportInput = {
        ...input,
        currentDate: new Date().toLocaleDateString('ko-KR'),
    };

    const { output } = await jiraReportFlow(fullInput);
    if (!output) {
      throw new Error('AI가 리포트를 생성하는 데 실패했습니다. 입력 데이터나 분석 관점을 확인해주세요.');
    }
    return output;
}

const jiraReportPrompt = ai.definePrompt({
    name: 'jiraReportPrompt',
    input: { schema: JiraReportInputSchema },
    output: { schema: JiraReportOutputSchema },
    prompt: `You are an expert project management AI that analyzes Jira data and generates comprehensive reports in KOREAN. Your entire response MUST be a single, valid JSON object that adheres to the output schema.

Today's date is {{{currentDate}}}.

**CRITICAL RULES:**
1.  **PROCESS ONLY VALID DATA:** A row in the input data is valid ONLY IF it contains BOTH an 'Issue Key' (like 'ABC-123') AND a 'Summary' value. You MUST completely ignore any row that is empty, malformed, or does not have both these values. Do not create objects for invalid rows.
2.  **STRICT JSON OUTPUT:** Your entire response MUST be a single, valid, complete, and parseable JSON object. No extra text or explanations.

**ANALYSIS INSTRUCTIONS:**

{{#if analysisPoint}}
The user wants you to specifically focus on: '{{{analysisPoint}}}'.
You MUST filter the data based on this analysis point BEFORE generating the report.

-   **Date-based Query:** If the request is for a specific month or week (e.g., '2월에 해결된 이슈', '지난 주 생성된 이슈'), you MUST filter the issues by 'createdDate' or 'resolvedDate' first. The entire report (summary, actions, chart, breakdown) must be based ONLY on the filtered data.
-   **Keyword/General Query:** For other requests (e.g., '주요 병목 구간', a person's name, '결함'), filter the issues by status, assignee, or by searching the summary text. The entire report must be based on the filtered results.
{{else}}
Provide a general analysis of ALL valid issues.
{{/if}}

**JSON OUTPUT GENERATION:**

Based on the (potentially filtered) data, generate a JSON object with four keys: "statusDistribution", "summary", "priorityActions", and "issueBreakdown".

1.  **\`issueBreakdown\` (Array of Objects):**
    -   For each valid issue, create an object.
    -   'summary': MUST be a VERY SHORT summary of the original issue title, **under 15 words**.
    -   'recommendation': MUST be a VERY SHORT, actionable recommendation in **KOREAN**, **under 10 words**.
    -   'assignee'/'status': If a value is missing, use a sensible default like '담당자 없음' or '상태 없음'.
    -   'createdDate'/'resolvedDate': Extract from columns like 'Created', 'Resolved', '생성일', '해결일' if they exist.

2.  **\`statusDistribution\` (Array of Objects, for a pie chart):**
    -   Count the issues for each unique status from your processed \`issueBreakdown\` list.
    -   Create an array of objects, each with \`name\` (status), \`value\` (count), and a unique, visually distinct hex \`fill\` color.

3.  **\`summary\` (String, in Korean):**
    -   Write a high-level summary of the issues you analyzed. Use the counts from your \`statusDistribution\` analysis.
    -   The summary MUST reflect the '{{{analysisPoint}}}' if provided.

4.  **\`priorityActions\` (Array of Strings, in Korean):**
    -   List the top 3-5 most critical actions based on your analysis.
    -   The actions MUST be directly related to the '{{{analysisPoint}}}' if provided.

**Input Jira Data (JSON Array of Arrays):**
{{{issuesData}}}

Now, generate the complete JSON report strictly following all rules.`,
});

const jiraReportFlow = ai.defineFlow(
    {
        name: 'jiraReportFlow',
        inputSchema: JiraReportInputSchema,
        outputSchema: JiraReportOutputSchema,
    },
    async (input) => {
        const { output } = await jiraReportPrompt(input);
        if (!output) {
            // This case might be hit if the AI returns a non-JSON string or empty response.
            throw new Error('AI returned an invalid or empty response.');
        }

        // Add a final safety net. If breakdown is empty, throw a clearer user-facing error.
        if (!output.issueBreakdown || output.issueBreakdown.length === 0) {
            throw new Error('AI가 유효한 이슈를 분석하지 못했습니다. 데이터에 이슈 키와 요약 정보가 포함되어 있는지 확인해주세요.');
        }

        return output;
    }
);
